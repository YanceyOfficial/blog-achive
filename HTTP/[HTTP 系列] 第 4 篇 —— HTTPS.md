# [HTTP 系列] 第 4 篇 —— HTTPS

> 这里是《写给前端工程师的 HTTP 系列》, 记得有位大佬曾经说过: **大厂前端面试对 HTTP 的要求比 CSS 还要高**, 由此可见 HTTP 的重要程度不可小视. 文章写作计划如下, 视情况可能有一定的删减, 本篇是该系列的第 4 篇 —— HTTPS.

## HTTPS 出现的原因及安全四要素

由于 HTTP 天生**明文传输**的特点, 整个传输过程完全透明, 任何人都能够在链路中截获, 修改或者伪造请求或者响应报文, 数据不具有可信性. 通常认为, 如果通信过程具备了四个特性, 就可以认为是**安全**的, 这四个特性是: 机密性, 完整性, 身份认证和不可否认.

- 机密性(Secrecy/Confidentiality)是指对数据的**保密**, 只能由可信的人访问, 对其他人是不可见的**秘密**, 简单来说就是不能让不相关的人看到不该看的东西.
- 完整性(Integrity, 也叫一致性)是指数据在传输过程中没有被篡改, 不多也不少, **完完整整**地保持着原状.
- 身份认证(Authentication)是指确认对方的真实身份, 也就是**证明你真的是你**, 保证消息只能发送给可信的人.
- 第四个特性是不可否认(Non-repudiation/Undeniable), 也叫不可抵赖, 意思是不能否认已经发生过的行为, 不能**说话不算数\*\***耍赖皮\*\*.

对于 HTTPS, 机密性由对称加密保证, 完整性由摘要算法保证, 身份认证和不可否认由非对称加密保证.

## 什么是 HTTPS

HTTPS 的本质是把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS, 由**HTTP over TCP/IP**变成了**HTTP over SSL/TLS**, 让 HTTP 运行在了安全的 SSL/TLS 协议上, 收发报文不再使用 Socket API, 而是调用专门的安全接口.

![HTTPS 和 HTTP 对比图](https://edge.yancey.app/beg/mxn6p11p-1647791764263.webp)

SSL 即安全套接层(Secure Sockets Layer), 在 OSI 模型中处于第 5 层(会话层), 由网景公司于 1994 年发明, 有 v2 和 v3 两个版本, 而 v1 因为有严重的缺陷从未公开过. SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议, 于是互联网工程组 IETF 在 1999 年把它改名为 TLS(传输层安全, Transport Layer Security), 正式标准化, 目前应用的最广泛的 TLS 是 1.2.

TLS 由记录协议, 握手协议, 警告协议, 变更密码规范协议, 扩展协议等几个子协议组成, 综合使用了对称加密, 非对称加密, 身份认证等许多密码学前沿技术. 浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信, 这些算法的组合被称为**密码套件**(cipher suite, 也叫加密套件).

下面这个例子中可以看出, 使用的 TLS 是 1.2, 客户端和服务器都支持非常多的密码套件, 密码套件的格式为 **密钥交换算法-签名算法-对称加密算法-分组模式-摘要算法**, 下面这个例子协商选定的是 **ECDHE-RSA-AES256-GCM-SHA384**. 即握手时使用 ECDHE 算法进行密钥交换, 用 RSA 签名和身份认证, 握手后的通信使用 AES 对称算法, 密钥长度 256 位, 分组模式是 GCM, 摘要算法 SHA384 用于消息认证和产生随机数. \*\*

![密码套件](https://edge.yancey.app/beg/inp3i46p-1647792347196.webp)

OpenSSL 是一个著名的开源密码学程序库和工具包, 几乎支持所有公开的加密算法和协议, 已经成为了事实上的标准, 许多应用软件都会使用它作为底层库来实现 TLS 功能, 包括常用的 Web 服务器 Apache, Nginx 等.

## 加密

实现机密性最常用的手段是**加密**(encrypt), 就是把消息用某种方式转换成谁也看不懂的乱码, 只有掌握特殊**钥匙**的人才能再转换出原始文本.

这里的**钥匙**就叫做**密钥**(key), 加密前的消息叫**明文**(plain text/clear text), 加密后的乱码叫**密文**(cipher text), 使用密钥还原明文的过程叫**解密**(decrypt), 是加密的反操作, 加密解密的操作过程就是**加密算法**. 所有的加密算法都是公开的, 任何人都可以去分析研究, 而算法使用的**密钥**则必须保密.

**密钥**就是一长串的数字, 但约定俗成的度量单位是**位**(bit), 而不是**字节**(byte). 比如, 说密钥长度是 128, 就是 16 字节的二进制串, 密钥长度 1024, 就是 128 字节的二进制串.

按照密钥的使用方式, 加密可以分为两大类: **对称加密**和**非对称加密**.

### 对称加密

**对称加密**就是指加密和解密时使用的密钥都是同一个, 是**对称**的. 只要保证了密钥的安全, 明文通过该密钥加密, 也通过该密钥解密, 外人拿到的只是一段被加密的乱码, 那整个通信过程就可以说具有了机密性.

![对称加密](https://edge.yancey.app/beg/g95l573a-1647798875927.webp)

TLS 里有非常多的对称加密算法可供选择, 比如 RC4, DES, 3DES, AES, ChaCha20 等, 但前三种算法都被认为是不安全的, 通常都禁止使用, 目前常用的只有 AES 和 ChaCha20. AES 的意思是**高级加密标准**(Advanced Encryption Standard), 密钥长度可以是 128, 192 或 256. 它是 DES 算法的替代者, 安全强度很高, 性能也很好, 而且有的硬件还会做特殊优化, 所以非常流行, 是应用最广泛的对称加密算法. ChaCha20 是 Google 设计的另一种加密算法, 密钥长度固定为 256 位, 纯软件运行性能要超过 AES, 曾经在移动客户端上比较流行, 但 ARMv8 之后也加入了 AES 硬件优化, 所以现在不再具有明显的优势, 但仍然算得上是一个不错的算法.

对称算法还有一个**分组模式(Block cipher, 又称分块加密或块密码)**的概念, 它将明文分成多个等长的模块(block), 使用确定的算法和对称密钥对每组分别加密解密. 这是因为在实际加密中, 一般加密的数据不会只有几百 bit, 而是几 mb, 甚至几 gb. 这样, 加密过程就是每加密 128bit 接着再加密 128bit, 直至将全部数据加密完. 最新的分组模式被称为 AEAD(Authenticated Encryption with Associated Data), 在加密的同时增加了认证的功能, 常用的是 GCM, CCM 和 Poly1305.

把上面这些组合起来, 就可以得到 TLS 密码套件中定义的对称加密算法. 比如, AES128-GCM, 意思是密钥长度为 128 位的 AES 算法, 使用的分组模式是 GCM；ChaCha20-Poly1305 的意思是 ChaCha20 算法, 使用的分组模式是 Poly1305.

### 非对称加密

对称加密看上去好像完美地实现了机密性, 但其中有一个很大的问题: 如何把密钥安全地传递给对方, 术语叫**密钥交换**. 因为在对称加密算法中只要持有密钥就可以解密. 如果你和网站约定的密钥在传递途中被黑客窃取, 那他就可以在之后随意解密收发的数据, 通信过程也就没有机密性可言了.

因此就出现了非对称加密, 它有两个密钥, 一个叫**公钥**(public key), 一个叫**私钥**(private key). 两个密钥是不同的, **不对称**, 公钥可以公开给任何人使用, 而私钥必须严格保密. 公钥和私钥有个特别的**单向**性, 虽然都可以用来加密解密, 但公钥加密后只能用私钥解密, 反过来, 私钥加密后也只能用公钥解密. 非对称加密可以解决**密钥交换**的问题. 网站秘密保管私钥, 在网上任意分发公钥, 你想要登录网站只要用公钥加密就行了, 密文只能由私钥持有者才能解密. 而黑客因为没有私钥, 所以就无法破解密文.

![非对称加密](https://edge.yancey.app/beg/u35cioie-1647801298144.webp)

非对称加密算法要比对称加密算法复杂的多, 在 TLS 里只有很少的几种, 比如 DH, DSA, RSA, ECC 等.

#### RSA 算法

RSA 可能是其中最著名的一个, 几乎可以说是非对称加密的代名词, 它的安全性基于**整数分解**的数学难题, 使用两个超大素数的乘积作为生成密钥的材料, 想要从公钥推算出私钥是非常困难的. 以前 RSA 密钥推荐使用 1024 位, 但随着计算机运算能力的提高, 现在 1024 已经不安全, 普遍认为至少要 2048 位.

第一步选择两个大质数 p 和 q, p 不等于 q, 计算 N=p \* q;

第二步是根据欧拉函数获取 r, 即 `r = φ(N) = φ(p)φ(q) = (p-1)(q-1)`. 欧拉函数 φ(n) 的定义是**小于或等于 n 的正整数中与 n 互质(如果两个或两个以上的整数的最大公约数是 1, 则称它们为互质)的数的数目**.

举个例子, φ(3 \* 5) = 15, 其互质数有 1, 2, 4, 7, 8, 11, 13, 14. 关于欧拉公式的推导可以看[这篇文章](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0).

#### ECC 算法

ECC(Elliptic Curve Cryptography)是非对称加密里的**后起之秀**, 它基于**椭圆曲线离散对数**的数学难题, 使用特定的曲线方程和基点生成公钥和私钥, 子算法 ECDHE 用于密钥交换, ECDSA 用于数字签名. 目前比较常用的两个曲线是 P-256(secp256r1, 在 OpenSSL 称为 prime256v1)和 x25519. P-256 是 NIST(美国国家标准技术研究所)和 NSA(美国国家安全局)推荐使用的曲线, 而 x25519 被认为是最安全, 最快速的曲线.

比起 RSA, ECC 在安全强度和性能上都有明显的优势. 160 位的 ECC 相当于 1024 位的 RSA, 而 224 位的 ECC 则相当于 2048 位的 RSA. 因为密钥短, 所以相应的计算量, 消耗的内存和带宽也就少, 加密解密的性能就上去了, 对于现在的移动互联网非常有吸引力.

如下图是两个椭圆曲线 `y^2=x^3+7`, `y^2=x^3-x`.

![ECC 算法](https://edge.yancey.app/beg/cx3u6ed8-1647805889570.jpg)

### 混合加密

虽然非对称加密能解决密钥交换的安全问题, 但由于它们都是基于复杂的数学难题, 运算速度很慢, 而对称加密使用的是位运算, 相对就很快. 即使是 ECC 也要比 AES 差上好几个数量级. 这样虽然保证了安全, 但无法保证速度. 因此, 在实际应用中, TLS 里使用的混合加密方式来保障机密性.

即在通信刚开始的时候使用非对称算法, 比如 RSA, ECDHE, 首先解决密钥交换的问题.

然后用随机数产生对称算法使用的**会话密钥**(session key), 再用公钥加密. 因为会话密钥很短, 通常只有 16 字节或 32 字节, 所以慢一点也无所谓.

对方拿到密文后用私钥解密, 取出会话密钥. 这样, 双方就实现了对称密钥的安全交换, 后续就不再使用非对称加密, 全都使用对称加密. 这样混合加密就解决了对称加密算法的密钥交换问题, 而且安全和性能兼顾, 完美地实现了机密性.

![混合加密示意图](https://edge.yancey.app/beg/w7drrjqk-1647806315377.webp)

## 摘要算法

混合加密保障了数据的机密性, 但仍然无法保障完整性, 因为虽然黑客无法破解机密数据, 但如果给加密后的数据添油加醋, 甚至篡改, 那么最终接收到的数据仍是残缺的. 因此需要一种机制来保障数据的完整性.

实现完整性的手段主要是摘要算法(Digest Algorithm), 也就是常说的散列函数, 哈希函数(Hash Function). 它能够把任意长度的数据**压缩**成固定长度, 而且独一无二的**摘要**字符串, 就好像是给这段数据生成了一个数字**指纹**. 摘要算法实际上是把数据从一个**大空间**映射到了**小空间**, 所以就存在**冲突**(collision, 也叫碰撞)的可能性, 即有两份或多份不同的原文对应相同的摘要. 好的摘要算法必须能够**抵抗冲突**, 让这种可能性尽量地小.

常见的摘要算法有 MD5(Message-Digest 5), SHA-1(Secure Hash Algorithm 1), 能够生成 16 字节和 20 字节长度的数字摘要. 但这两个算法的安全强度比较低, 不够安全, 在 TLS 里已经被禁止使用了. 目前 TLS 推荐使用的是 SHA-2. SHA-2 实际上是一系列摘要算法的统称, 总共有 6 种, 常用的有 SHA224, SHA256, SHA384, 分别能够生成 28 字节, 32 字节, 48 字节的摘要.

因为摘要算法对输入具有**单向性**和**雪崩效应**, 输入的微小不同会导致输出的剧烈变化, 所以也被 TLS 用来生成伪随机数(PRF, pseudo random function).

摘要算法保证了**数字摘要**和原文是完全等价的. 所以, 我们只要在原文后附上它的摘要, 就能够保证数据的完整性. 比如, 你发了条消息: **转账 1000 元**, 然后再加上一个 SHA-2 的摘要. 网站收到后也计算一下消息的摘要, 把这两份**指纹**做个对比, 如果一致, 就说明消息是完整可信的, 没有被修改.

![摘要算法](https://edge.yancey.app/beg/ywqao5x7-1647883741961.webp)

通过使用摘要算法来保障数据的完整性, 但如果是明文传输, 数据仍然是会被泄露的, 因此完整性必须要建立在机密性之上, 在混合加密系统里用会话密钥加密消息和摘要, 这样黑客无法得知明文, 也就没有办法动手脚了. 这里有个术语, 叫哈希消息认证码(HMAC). 它通过特别计算方式之后产生的消息认证码(MAC), 使用密码散列函数, 同时结合一个加密密钥. 它可以用来保证资料的完整性, 同时可以用来作某个消息的身份验证. 具体的算法可参考 [HMAC](https://zh.wikipedia.org/wiki/HMAC).

![哈希消息认证码](https://edge.yancey.app/beg/7eflrll0-1647884511734.webp)

## 数字签名

似乎加密算法结合摘要算法已经保障了数据的机密性和完整性, 但这里有个漏洞. 上面说的都是黑客可以伪装成网站来窃取你的信息, 但反过来, 黑客也可以冒充你向网站发送支付, 转账等消息, 网站没有办法确认你的身份, 钱可能就这么被偷走了. 现实生活中我们通过签名或印章, 来证明**我是我**. 这种只能由本人持有, 而其他任何人都不会有的便是**私钥**.

数字签名的原理其实很简单, 就是把公钥私钥的用法反过来, 之前是公钥加密, 私钥解密, 现在是私钥加密, 公钥解密. 但又因为非对称加密效率太低, 所以私钥只加密原文的摘要, 这样运算量就小的多, 而且得到的数字签名也很小, 方便保管和传输. 签名和公钥一样完全公开, 任何人都可以获取. 但这个签名只有用私钥对应的公钥才能解开, 拿到摘要后, 再比对原文验证完整性, 就可以像签署文件一样证明消息确实是你发的(这个工程的专业术语叫做**验签**). 这种使用私钥加密摘要的策略, 就能够实现**数字签名**, 同时实现**身份认证**和**不可否认**.

![数字签名过程](https://edge.yancey.app/beg/xrm7ssui-1647948635651.webp)

只要你和网站互相交换公钥, 就可以用**签名**和**验签**来确认消息的真实性, 因为私钥保密, 黑客不能伪造签名, 就能够保证通信双方的身份. 比如, 你用自己的私钥签名一个消息**我是小明**. 网站收到后用你的公钥验签, 确认身份没问题, 于是也用它的私钥签名消息**我是某宝**. 你收到后再用它的公钥验一下, 也没问题, 这样你和网站就都知道对方不是假冒的, 后面就可以用混合加密进行安全通信了.

## 数字证书和 CA

上面说道**只要你和网站互相交换公钥, 就可以用**签名**和**验签**来确认消息的真实性**. 不知道你是否有疑惑, 因为公钥是公开的, 谁都可以发布公钥, 我们还缺少防止黑客伪造公钥的手段, 也就是说, 怎么来判断这个公钥就是你或者某宝的公钥呢? 这就需要 CA(Certificate Authority, 证书认证机构)来帮助我们. 它具有极高的可信度, 由它来给各个公钥签名, 用自身的信誉来保证公钥无法伪造, 是可信的.

CA 对公钥的签名认证也是有格式的, 不是简单地把公钥绑定在持有者身份上就完事了, 还要包含序列号, 用途, 颁发者, 有效时间等等, 把这些打成一个包再签名, 完整地证明公钥关联的各种信息, 形成**数字证书**(Certificate).

证书根据等级分为 DV, OV, EV 三种:

| 类型/区别 | 审核内容                             | 颁发周期      | 使用年限    | 浏览器显示形式                         | 适用对象                                                 | 价格                                              |
| --------- | ------------------------------------ | ------------- | ----------- | -------------------------------------- | -------------------------------------------------------- | ------------------------------------------------- |
| DV        | 域名所有权                           | 几分钟-几小时 | 1-2 年      | https + 小锁标志                       | 中小型企业网站, 电子商务网站, 电子邮局服务器, 个人网站等 | 免费                                              |
| OV        | 域名所有权；企业信息；               | 2-3 个工作日  | 1-2 年      | https + 小锁标志                       | 企业网站, 电子商务网站, 证券, 金融机构等                 | 2,982.40 元/年 <span style="color: red">\*</span> |
| EV        | 域名所有权；企业信息；第三方数据核查 | 5-7 个工作日  | 一 1-2 年年 | https + 小锁标志 + 绿色网址 + 企业名称 | 银行, 保险, 金融机构, 电子商务网站, 大型企业等           | 6,400 元/年 <span style="color: red">\*</span>    |

> 上述价格节选自阿里云单域名每年的价格, 时间为 2022/03/23, 具体价格以实际购买时的价格为准.

不过, CA 怎么证明自己呢? 这还是信任链的问题. 小一点的 CA 可以让大 CA 签名认证, 但链条的最后, 也就是 Root CA, 就只能自己证明自己了, 这个就叫**自签名证书**(Self-Signed Certificate)或者**根证书**(Root Certificate). 你必须相信, 否则整个证书信任链就走不下去了.

![证书自证](https://edge.yancey.app/beg/4azofok4-1647997260175.webp)

有了这个证书体系, 操作系统和浏览器都内置了各大 CA 的根证书, 上网的时候只要服务器发过来它的证书, 就可以验证证书里的签名, 顺着证书链(Certificate Chain)一层层地验证, 直到找到根证书, 就能够确定证书是可信的, 从而里面的公钥也是可信的.

### 证书体系的弱点

证书体系(PKI, Public Key Infrastructure)虽然是目前整个网络世界的安全基础设施, 但绝对的安全是不存在的, 它也有弱点, 还是关键的**信任**二字. 如果 CA 失误或者被欺骗, 签发了错误的证书, 虽然证书是真的, 可它代表的网站却是假的. 还有一种更危险的情况, CA 被黑客攻陷, 或者 CA 有恶意, 因为它(即根证书)是信任的源头, 整个信任链里的所有证书也就都不可信了.

针对第一种, 开发出了 CRL(证书吊销列表, Certificate revocation list)和 OCSP(在线证书状态协议, Online Certificate Status Protocol), 及时废止有问题的证书. 对于第二种, 因为涉及的证书太多, 就只能操作系统或者浏览器从根上**下狠手**了, 撤销对 CA 的信任, 列入**黑名单**, 这样它颁发的所有证书就都会被认为是不安全的.

## TLS 保障安全性的小结

TLS 通过以下几点来保证机密性, 完整性, 身份认证和不可否认.

- 摘要算法用来实现完整性, 能够为数据生成独一无二的**指纹**, 常用的算法是 SHA-2；
- 数字签名是私钥对摘要的加密, 可以由公钥解密后验证, 实现身份认证和不可否认；
- 公钥的分发需要使用数字证书, 必须由 CA 的信任链来验证, 否则就是不可信的；
- 作为信任链的源头 CA 有时也会不可信, 解决办法有 CRL, OCSP, 还有终止信任.

## HTTPS 握手

在 HTTP 协议里，通过三次握手建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS 协议，它需要再用另外一个“握手”过程，在 TCP 上建立安全连接，之后才是收发 HTTP 报文。在讲 TLS 握手之前，先简单介绍一下 TLS 协议的组成。

### TLS 协议的组成

TLS 协议有多个模块组成, 比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。

**记录协议**（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。

**警报协议**（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。

**握手协议**（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。

**变更密码规范协议**（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。

下面的这张图简要地描述了 TLS 的握手过程，其中每一个“框”都是一个记录，多个记录组合成一个 TCP 包发送。所以，最多经过两次消息往返（4 个消息）就可以完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。

![TLS 协议](https://edge.yancey.app/beg/2gloicuc-1647999700009.webp)

### ECDHE 详细握手过程

![ECDHE 详细握手过程](https://edge.yancey.app/beg/2gloicuc-1647999700009.webp)

在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。这个的意思就是：“我这边有这些这些信息，你看看哪些是能用的，关键的随机数可得留着。”

```ts
Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Random: 1cbf803321fd2623408dfe…
    Cipher Suites (17 suites)
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)
```

服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了 “TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。

```ts
Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Random: 0e6320f21bae50842e96…
    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)
```
