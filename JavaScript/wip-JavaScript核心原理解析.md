# JavaScript 核心原理解析

## 引子

JavaScript 是一门多范型语言,也称为混合范型语言, 它既有 OOP 的特性, 也有函数式的特性. JavaScript 的简单来自于此, 复杂也来自于此; 生存能力来自于此, 抨击诟病也来自于此. JavaScript 主要包括 5 个方面的语言特性: 结构化编程, 面向对象编程, 动态语言, 函数式语言和并行语言. JavaScript 中, 有语句和表达式两种基本的可执行元素.

### 谈一谈 delete

我们使用 delete 最多的场景就是删除对象中的某个 key, 这是操作的一个引用类型. 其实仔细想想, `delete 0` 相当于删除一个基本类型, 甚至你还可以删除全局对象的某个 key, 比如在浏览器环境中, 你可以 `delete scrollX`. 因此, `delete x`, x 可以是引用类型, 也可以是基本类型, 也可以是全局对象(当然它也是引用类型).

首先看 `delete 0`, 0 是一个具体的字面量值, 是不可能删除掉的, 但 `delete 0` 仍然会返回 true,  这只表明执行过程中没有异常, 但实际的执行行为是"什么也没发生". 你显然不可能真的将 0 从执行系统中清理出去.

那么接下来, 就还剩下删除变量和删除属性, 由于全局变量实际上是通过全局对象的属性来实现的, 因此删除变量也就存在识别这两种行为的必要性. 出于 JavaScript 是动态语言这项特性, 从根本上来说, 我们是没有办法在语法分析期来判断 x 的性质的, 需要有一种方法在运行期来标识 x 的性质, 以便进一步地处理它.

对于一门编译型语言来说, 0 可以是原始类型 0, 也可以是数值类型 `Number(0)`. 但在编译之前, 也就是语法分析的阶段, 0 仅仅是一个 Token. 一个记号是没有语义的, 记号既可以是语言能识别的, 也可以是语言不能识别的. 唯有把这二者同时纳入语言范畴, 那么这个语言才能识别所谓的"语法错误". 因此, 这个语法实际起作用的是一个对象的属性, 也就是"删除对象的成员". **是删除 x 这个成员, 而不是删除 x 这个值**. 不过终归有一点是没错的: 既然没办法表达异常, 而 delete 0 又不产生异常, 那么它自然就该返回 true. 所以, delete 这个操作的正式语法设计并不是"删除某个东西", 而是"删除一个表达式的结果".

---

### 谈一谈 break

所谓可中断语句其实只有两种, 包括全部的循环语句, 以及 switch 语句. 在这两种语句内部使用的 break, 采用的就是这种处理机制, 即中断当前语句, 将执行逻辑交给下一语句. 第二种还有标签语句, JavaScript 和 Rust 都有该语法. 当然除了 break, 也可以是 continue.

```ts
// 在 if 语句的两个分支中都可以使用 break
// 在分支中深层嵌套的语句中也是可以使用 break 的
aaa: if (true) {
   ...
}
else {
  ...
  break aaa;
}
 
// 在 try...catch...finally 中也可以使用 break
bbb: try {
  ...
}
finally {
  break bbb;
}
```

在*重学前端*的课程学到了即便在 try 中 return 了, 还是会执行 finally 里面的代码, 这涉及 JavaScript 语句执行的完成状态(Completion Record), 如果在 try 或 try..finally 块中使用了 return, 那么这个 break 将发生于最后一行语句之后, 但是却是在 return 语句之前. 下面的代码会依次打印出 Hi, Here, 101. 换句话说, 虽然 try 里面有 return, 但到了 finally 语句的时候, 把 try 里面给 break 掉了, 这得以继续执行下面的语句. 因此, break 将语句的代码块理解为位置, 而不是理解为作用域 / 环境.

```ts
var i = 100;
function foo() {
  bbb: try {
    console.log("Hi");
    return i++; //  <- 位置 1: i++ 表达式将被执行
  } finally {
    break bbb;
  }
  console.log("Here");
  return i; //  <- 位置 2
}


function f() {
  try {
    return 1;
  } finally {
    console.log("finally");
  }

  console.log("a"); // 执行不到了
}
```

JavaScript 的执行机制包括**执行权**和**数据资源**两个部分, 分别映射可计算系统中的**逻辑**与**数据**. 而块级作用域(也称为词法作用域)以及其他的作用域本质上就是一帧数据, 以保存执行现场的一个瞬时状态(也就是每一个执行步骤后的现场快照). 而 JavaScript 的运行环境被描述为一个后入先出的栈, 这个栈顶永远就是当前**执行权**的所有者持用的那一帧数据, 也就是代码活动的现场.

JavaScript 的运行环境通过函数的 CALL/RETURN 来模拟上述**数据帧**在栈上的入栈与出栈过程. 任何一次函数的调用, 即是向栈顶压入该函数的上下文环境(也就是作用域, 数据帧等等, 它们在不同场合下的相同概念). 所以, 包括那些在全局或模块全局中执行的代码, 以及 Promise 中执行调度的那些内部处理, 所有的这些 JavaScript 内部过程或外部程序都统一地被封装成函数, 通过 CALL/RETURN 来激活, 挂起.

所以, **作用域**就是在上述过程中被操作的一个对象.

- 作用域退出, 就是函数 RETURN.
- 作用域挂起, 就是执行权的转移.
- 作用域的创建, 就是一个闭包的初始化.
- ...

而 `break labelName` 这一语法独立于**执行过程** 的体系, 它表达一个位置的跳转, 而不是一个数据帧在栈上的进出栈. 这是 labelName 独立于标识符体系(也就是词法环境)所带来的附加收益. 当然 JavaScript 用来抹平这种跳转所带来的影响, 需要额外的设计.

### 语句执行的完成状态(Completion Record)

语句执行与函数执行并不一样. 函数是求值, 所以返回的是对该函数求值的结果(Result), 该结果或是值(Value), 或是结果的引用(Reference). 而语句是命令, 语句执行的返回结果是该命令得以完成的状态(Completion, Completion Record Specification Type). 语句执行总是返回它的完成状态.

在 ECMAScript 规范层面, 本质上所有 JavaScript 的执行都是语句执行(这很大程度上解释了为什么 eval 是执行语句). 因此, ECMAScript 规范中对执行的描述都称为**运行期语义(Runtime Semantics)**, 它描述一个 JavaScript 内部的行为或者用户逻辑的行为的过程与结果. 也就是说这些运行期语义都最终会以一个完成状态(Completion)来返回. 例如:

- 一个函数的调用: 调用函数——执行函数体(EvaluateBody)并得到它的**完成**结果(result).
- 一个块语句的执行: 执行块中的每行语句, 得到它们的**完成**结果(result).

这些结果(result)包括的状态有五种, 称为完成的类型:

- 正常完成(normal)
- 一个函数调用的返回(return)
- 循环过程中的继续下次迭代(continue)
- 中断(break)
- 异常(throw)

所以当运行期出现了一这个称为**中断(break)**的状态时, JavaScript 引擎需要找到这个**break**标示的目标位置(result.Target), 然后与当前语句的标签(如果有的话)对比:

- 如果一样, 则取 break 源位置的语句执行结果为值(Value)并以正常完成状态返回;
- 如果不一样, 则继续返回 break 状态.

在这个示例中, **break aaa**语句是发生于 bbb 标签所示块中的. 但当这个中断发生时:

- 标签化语句 bbb 将首先捕获到这个语句完成状态, 并携带有标签 aaa
- 由于 bbb 语句完成时检查到的状态中的中断目标(Target)与自己的标签不同, 所以它将这个状态继续作为自己的完成状态, 返回给外层的 aaa 标签化语句 aaa;
- 语句 aaa 得到上述状态, 并对比标签成功, 返回结果为语句 `3 + 4` 的值(作为完成状态传出).

```ts
console.log(
  eval(`
  aaa: {
    1 + 2;
    bbb: {
     3 + 4;
     break aaa;
    }
  }
`)
);
 // 输出值: 7
```

下面是一些有用的结论, 任何被 break 的代码上下文中, 最后执行语句必然会是**break 语句**本身. **break 语句**不返回任何值(ECMAScript 内部约定用**Empty**值来表示); **不返回任何值**的语句, 也不会影响任何语句的既有返回值. **break 语句**返回值的两个关键特性的由来: 它的类型必然是**break**; 它的返回值必然是**空(Empty)**.

### 谈一谈 JavaScript 中的模版

模板, 其实就是一种特殊的可执行结构. 所有特殊可执行结构其实都是来自于某种固定的, 确定的逻辑. 这些逻辑语义是非常明确的, 输入输出都很确定, 这样才能被设计成一个标准的, 易于理解的可执行结构.

#### 参数表
