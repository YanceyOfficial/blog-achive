# 浅析 V8 原理

> 这篇文章是李兵老师《图解 Google V8》的笔记, 也当作以后读 V8 源码的参考. 至于后面到底读不读, 先 🐎 住, 后面再说嘛...

## 什么是 V8

V8 是 JavaScript 虚拟机的一种, 它将人类能够理解的编程语言 JavaScript, 编译成成机器能够理解的机器语言. 市面上有很多种 JavaScript 引擎, 诸如 SpiderMonkey, V8, JavaScriptCore 等. 但 V8 绝对是最牛逼的那个, 在 V8 出现之前, 所有的 JavaScript 虚拟机所采用的都是**解释执行**的方式. 而 V8 率先使用即时编译(JIT) 的双轮驱动的设计, 即使用混合编译执行和解释执行这两种手段. 换句人话, 就是对于 JavaScript 代码, 首先是编译执行, 转换成字节码, 然后会将多次使用的热点代码转化成机器码. 此外, V8 也是早于其他虚拟机引入了惰性编译, 内联缓存, 隐藏类等机制.

V8 执行一段 JavaScript 代码需要通过**编译**和**执行**这两个过程. 首先需要将 JavaScript 代码转换为低级中间代码或者机器能够理解的机器代码, 然后再执行转换后的代码并输出执行结果.

![V8 工作原理概览](https://edge.yancey.app/beg/40c9w2bm-1652032140351.webp)

## 为什么高级语言需要被编译

这里首先补点儿课, 来聊一聊为什么高级语言需要被编译. 我们知道 **CPU** 只能跟**二进制的指令**进行沟通. 比如我们给 CPU 发出 **1000100111011000** 的二进制指令, 这条指令的意思是将一个寄存器中的数据移动到另外一个寄存器中, 当处理器执行到这条指令的时候, 便会按照指令的意思去实现相关的操作.

为了能够完成复杂的任务, 工程师们为 CPU 提供了一大堆指令, 来实现各种功能, 我们就把这一大堆指令称为**指令集(Instructions)**, 也就是**机器语言**. 二进制代码难以阅读和记忆, 于是我们又将二进制指令集转换为人类可以识别和记忆的符号, 这就是**汇编指令集**. 当然汇编语言仍然不能被 CPU 直接使用, 所以如果我们使用汇编编写了一段程序, 我们还需要一个汇编编译器, 来将汇编代码编程成机器代码.

```c
1000100111011000 // 机器指令
mov ax,bx        // 汇编指令
```

即便汇编语言对机器语言做了一层抽象, 仍然难以快速写出一段代码. 除了汇编语言仍然难以记忆, 还有如下两个原因:

- 不同的 CPU 有着不同的指令集, 市面上的 CPU 有 x86 架构的, arm 架构的等等, 如果要使用机器语言或者汇编语言来实现一个功能, 那么我们需要为每种架构的 CPU 编写特定的汇编代码.
- 在编写汇编代码时, 我们还需要了解和处理器架构相关的硬件知识, 比如寄存器, 内存, 操作 CPU 等等.

因此我们需要一种屏蔽了计算机架构细节的语言, 能适应多种不同 CPU 架构的语言, 能专心处理业务逻辑的语言, 诸如 C, C++, Java, C#, Python, JavaScript 等, 这些**高级语言**就应运而生了. 和汇编语言一样, 处理器也不能直接识别由高级语言所编写的代码, 通常会有两种方式来执行这些代码.

第一种是**解释执行**, 需要先将输入的源代码通过解析器编译成中间代码, 之后直接使用解释器解释执行中间代码, 然后直接输出结果.

![解释执行](https://edge.yancey.app/beg/gbs5kchb-1652032800141.webp)

第二种是**编译执行**. 采用这种方式时, 也需要先将源代码转换为中间代码, 然后我们的编译器再将中间代码编译成机器代码. 通常编译成的机器代码是以二进制文件形式存储的, 需要执行这段程序的时候直接执行二进制文件就可以了. 还可以使用虚拟机将编译后的机器代码保存在内存中, 然后直接执行内存中的二进制代码.

![编译执行](https://edge.yancey.app/beg/rql7jlta-1652032807344.webp)

## V8 工作原理概览

V8 其实是一个虚拟机, 虚拟机通过模拟实际计算机的各种功能来实现代码的执行, 如模拟实际计算机的 CPU, 堆栈, 寄存器等, 虚拟机还具有它自己的一套指令系统. 对于 JavaScript 代码来说, V8 就是它的整个世界, 当 V8 执行 JavaScript 代码时, 我们并不需要担心现实中不同操作系统的差异, 也不需要担心不同体系结构计算机的差异, 我们只需要按照虚拟机的规范写好代码就可以了.

V8 并没有采用某种单一的编译技术, 而是混合编译执行和解释执行这两种手段, 我们把这种混合使用编译器和解释器的技术称为 **JIT(Just In Time)**. 这是一种权衡策略, 因为这两种方法都各自有各自的优缺点, 解释执行的启动速度快, 但是执行时的速度慢, 而编译执行的启动速度慢, 但是执行时的速度快.

![V8 编译流水线](https://edge.yancey.app/beg/19m6ctx7-1652029505251.webp)

首先看上图左边部分, V8 启动执行 JavaScript 之前, 它还需要准备执行 JavaScript 时所需要的一些基础环境, 这些基础环境包括了**堆空间**, **栈空间**, **全局执行上下文**, **全局作用域**, **消息循环系统**, **内置函数**等, 这些内容都是在执行 JavaScript 过程中需要使用到的.

- JavaScript 全局执行上下文就包含了执行过程中的全局信息, 比如一些内置函数, 全局变量等信息；
- 全局作用域包含了一些全局变量, 在执行过程中的数据都需要存放在内存中；
- 而 V8 是采用了经典的堆和栈的内存管理模式, 所以 V8 还需要初始化内存中的堆和栈结构；
- 另外, 想要我们的 V8 系统活起来, 还需要初始化消息循环系统, 消息循环系统包含了消息驱动器和消息队列, 它如同 V8 的心脏, 不断接受消息并决策如何处理消息.

基础环境准备好之后, 接下来就可以向 V8 提交要执行的 JavaScript 代码了. V8 会进行一系列的**结构化**操作, 即词法分析, 语法分析等等, 此时就生成了 AST 和作用域.

有了 AST 和作用域, 接下来就可以生成字节码了, 字节码是介于 AST 和机器代码的中间代码. 但是与特定类型的机器代码无关, 解释器可以直接解释执行字节码, 或者通过编译器将其编译为二进制的机器代码再执行.

生成了字节码之后, 解释器就会按照顺序解释执行字节码, 并输出执行结果.

我们在解释器附近画了个监控机器人, 这是一个监控解释器执行状态的模块, 在解释执行字节码的过程中, 如果发现了某一段代码会被重复多次执行, 那么监控机器人就会将这段代码标记为**热点代码**. 当某段代码被标记为热点代码后, V8 就会将这段字节码丢给优化编译器, 优化编译器会在后台将字节码编译为二进制代码, 然后再对编译后的二进制代码执行优化操作, 优化后的二进制机器代码的执行效率会得到大幅提升. 如果下面再执行到这段代码时, 那么 V8 会优先选择优化之后的二进制代码, 这样代码的执行速度就会大幅提升.

不过由于 JavaScript 是一门动态语言, 对象的结构和属性是可以在运行时任意修改的, 而经过优化编译器优化过的代码只能针对某种固定的结构, 一旦在执行过程中, 对象的结构被动态修改了, 那么优化之后的代码势必会变成无效的代码, 这时候优化编译器就需要执行**反优化**操作, 经过反优化的代码, 下次执行时就会回退到解释器解释执行.

## JavaScript 的设计思想

我们知道 V8 的主要职责是用来执行 JavaScript 代码的, 在深入 V8 之前, 我们首先需要了解 JavaScript 这门语言的基本特性和设计思想.

JavaScript 借鉴了很多语言的特性, 比如 C 语言的基本语法, Java 的类型系统和内存管理, Scheme 的函数作为一等公民, 还有 Self 基于原型(prototype)的继承机制. 毫无疑问, JavaScript 是一门非常优秀的语言, 特别是**原型继承机制**和**函数是一等公民**这两个设计.

但操蛋的是, 由于历史原因, 很多错误的或者不合理的设计都被延续至今, 比如使用 new 加构造函数来创建对象, 这种方式的背后隐藏了太多的细节, 非常容易增加代码出错概率, 而且也大大增加了新手的学习成本；再比如初期的 JavaScript 没有块级作用域机制, 使得 JavaScript 需要采取变量提升的策略, 而变量提升又是非常反人性的设计.

因此在学习 V8 工作原理时, 我们就要格外关注 JavaScript 这些独特的设计思想和特性背后的实现. 比如, 为了实现函数是一等公民的特性, JavaScript 采取了基于对象的策略；再比如为了实现原型继承, V8 为每个对象引入了 `__proto__` 属性等等.

![JavaScript 的设计思想](https://edge.yancey.app/beg/ppo5m3ha-1652029158898.webp)

### 函数即对象

### 快属性和慢属性

### 函数表达式

### 原型链

### 作用域链

### 类型转换

## V8 编译流水线

我们把 V8 执行 JavaScript 代码的这套流程称之为 V8 的编译流水线. 它涉及 JIT, 延迟解析, 隐藏类, 内联缓存等等. 这些技术决定着一段 JavaScript 代码能否正常执行, 以及代码的执行效率.

比如 V8 中使用的隐藏类(Hide Class), 这是将 JavaScript 中动态类型转换为静态类型的一种技术, 可以消除动态类型的语言执行速度过慢的问题, 那么我们在编写 JavaScript 时, 就可以充分利用好隐藏类这种强大的优化特性, 写出更加高效的代码. 再比如, V8 实现了 JavaScript 代码的惰性解析, 目的是为了加速代码的启动速度, 通过对惰性解析机制的学习, 我们可以优化代码来更加适应这个机制, 从而提高程序性能.

## 从 V8 看事件循环系统

事件循环系统和 JavaScript 中的难点, 异步编程特性紧密相关. 我们知道, JavaScript 是单线程的, JavaScript 代码都是在一个线程上执行, 如果同一时间发送了多个 JavaScript 执行的请求, 就需要排队, 也就是进行异步编程. V8 的事件循环系统会调度这些排队任务, 保证 JavaScript 代码被 V8 有序地执行. 因此也可以说, 事件循环系统就是 V8 的心脏, 它驱动了 V8 的持续工作.

## 从 V8 看垃圾回收

我们知道 JavaScript 是一种自动垃圾回收的语言, V8 在执行垃圾回收时, 会占用主线程的资源. 如果我们编写的程序频繁触发垃圾回收, 那么无疑会阻塞主线程, 这也是我们经常会遇到的一个问题. 因此我们需要知道 V8 是如何分配内存数据的, 以及这些数据是如何被回收的. 这样在遇到内存问题时, 就知道如何去排查了.

## 实践: 玩一玩 D8

要查看 V8 中间生成的一些结构, 可以使用 V8 提供的调试工具 D8 来查看. 注意不要使用 `brew install v8` 安装, 因为这个是生产环境的 V8, 而我们需要安装 debug 版本的 V8, 才可以进行一些调试. 你可以使用 [jsvu](https://github.com/GoogleChromeLabs/jsvu), 它是一个 JavaScript 引擎版本更新器, 你可以通过这个工具安装 debug 版本的 V8.

![V8 debug](https://edge.yancey.app/beg/sjzukz6d-1652107415952.jpg)

```ts
const name = "yancey";

function sayHi() {
  const params = {};
  return "Hi";
}
```

以上面这段代码为例, 我们执行 `d8 --print-ast index.js`, 就可以获取到抽象语法树的结构.

```ts
[generating bytecode for function: ]
--- AST ---
FUNC at 0
. KIND 0
. LITERAL ID 0
. SUSPEND COUNT 0
. NAME ""
. INFERRED NAME ""
. DECLS
. . VARIABLE (0x7fa8e701f250) (mode = CONST, assigned = false) "name"
. . FUNCTION "sayHi" = function sayHi
. BLOCK NOCOMPLETIONS at -1
. . EXPRESSION STATEMENT at 13
. . . INIT at 13
. . . . VAR PROXY context[2] (0x7fa8e701f250) (mode = CONST, assigned = false) "name"
. . . . LITERAL "yancey"
```

我们执行 `d8 --print-scopes test.js`, 就可以获取到作用域, 我们看到了 sayHi 和 name 都被加入到了全作用域, params 被加入到 sayHi 函数的内部作用域.

```ts
Inner function scope:
function sayHi () { // (0x7f832e00cee0) (38, 80)
  // NormalFunction
  // 2 heap slots
  // local vars:
  CONST params;  // (0x7f832e00fa48) never assigned
}
Global scope:
global { // (0x7f832e00cc30) (0, 80)
  // will be compiled
  // NormalFunction
  // 1 stack slots
  // 3 heap slots
  // temporary vars:
  TEMPORARY .result;  // (0x7f832e00d130) local[0]
  // local vars:
  CONST name;  // (0x7f832e00ce50) context[2], never assigned
  VAR sayHi;  // (0x7f832e00d0a0)

  function sayHi () { // (0x7f832e00cee0) (38, 80)
    // lazily parsed
    // NormalFunction
    // 2 heap slots
  }
}
```

我们可以通过 `d8 --print-bytecode index.js` 来获取字节码.

```ts
[generated bytecode for function:  (0x325400253915 <SharedFunctionInfo>)]
Bytecode length: 38
Parameter count 1
Register count 3
Frame size 24
Bytecode age: 0
         0x3254002539e2 @    0 : 13 00             LdaConstant [0]
         0x3254002539e4 @    2 : c3                Star1
         0x3254002539e5 @    3 : 19 fe f8          Mov <closure>, r2
         0x3254002539e8 @    6 : 65 58 01 f9 02    CallRuntime [DeclareGlobals], r1-r2
         0x3254002539ed @   11 : 13 01             LdaConstant [1]
         0x3254002539ef @   13 : 25 02             StaCurrentContextSlot [2]
         0x3254002539f1 @   15 : 21 02 00          LdaGlobal [2], [0]
         0x3254002539f4 @   18 : c3                Star1
         0x3254002539f5 @   19 : 61 f9 02          CallUndefinedReceiver0 r1, [2]
         0x3254002539f8 @   22 : 21 02 00          LdaGlobal [2], [0]
         0x3254002539fb @   25 : c3                Star1
         0x3254002539fc @   26 : 61 f9 04          CallUndefinedReceiver0 r1, [4]
         0x3254002539ff @   29 : 21 02 00          LdaGlobal [2], [0]
         0x325400253a02 @   32 : c3                Star1
         0x325400253a03 @   33 : 61 f9 06          CallUndefinedReceiver0 r1, [6]
         0x325400253a06 @   36 : c4                Star0
         0x325400253a07 @   37 : a9                Return
Constant pool (size = 3)
0x3254002539ad: [FixedArray] in OldSpace
 - map: 0x325400002239 <Map>
 - length: 3
           0: 0x325400253965 <FixedArray[2]>
           1: 0x3254002538c9 <String[6]: #yancey>
           2: 0x3254002538dd <String[5]: #sayHi>
Handler Table (size = 0)
Source Position Table (size = 0)
[generated bytecode for function: sayHi (0x325400253975 <SharedFunctionInfo sayHi>)]
Bytecode length: 5
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
         0x325400253b46 @    0 : 7d                CreateEmptyObjectLiteral
         0x325400253b47 @    1 : c4                Star0
         0x325400253b48 @    2 : 13 00             LdaConstant [0]
         0x325400253b4a @    4 : a9                Return
Constant pool (size = 1)
0x325400253b19: [FixedArray] in OldSpace
 - map: 0x325400002239 <Map>
 - length: 1
           0: 0x325400253ae1 <String[2]: #Hi>
Handler Table (size = 0)
Source Position Table (size = 0)
```

生成字节码之后, 解释器会解释执行这段字节码, 如果重复执行了某段代码, 监控器就会将其标记为热点代码, 并提交给编译器优化执行, 如果你想要查看那些代码被优化了, 可以使用下面的命令. 当然我们的代码太简单了, 没有被标记成热点代码的情况.

```shell
d8 --trace-opt test.js
```

如果要查看那些代码被反优化了, 可以使用如下命令行来查看.

```shell
pt --trace-deopt test.js
```

## 结语

![总结](https://edge.yancey.app/beg/8fqa4v7z-1652030438219.jpeg)
