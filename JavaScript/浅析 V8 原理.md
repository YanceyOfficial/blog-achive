# 浅析 V8 原理

> 这篇文章是李兵老师《图解 Google V8》的笔记, 也当作以后读 V8 源码的参考. 至于后面到底读不读, 先 🐎 住, 后面再说嘛...

## 什么是 V8

V8 是 JavaScript 虚拟机的一种, 它将人类能够理解的编程语言 JavaScript, 编译成成机器能够理解的机器语言. 市面上有很多种 JavaScript 引擎, 诸如 SpiderMonkey, V8, JavaScriptCore 等. 但 V8 绝对是最牛逼的那个, 在 V8 出现之前, 所有的 JavaScript 虚拟机所采用的都是**解释执行**的方式. 而 V8 率先使用即时编译(JIT) 的双轮驱动的设计, 即使用混合编译执行和解释执行这两种手段. 换句人话, 就是对于 JavaScript 代码需要经过**编译**和**执行**两个阶段, 其中编译过程是指 **V8 将 JavaScript 代码转换为字节码或者将多次使用的热点代码转化成二进制机器代码的阶段, 而执行阶段则是指解释器解释执行字节码, 或者是 CPU 直接执行二进制机器代码的阶段**. 此外, V8 也是早于其他虚拟机引入了惰性编译, 内联缓存, 隐藏类等机制.

![V8 工作原理概览](https://edge.yancey.app/beg/40c9w2bm-1652032140351.webp)

## 为什么高级语言需要被编译

这里首先补点儿课, 来聊一聊为什么高级语言需要被编译. 我们知道 **CPU** 只能跟**二进制的指令**进行沟通. 比如我们给 CPU 发出 **1000100111011000** 的二进制指令, 这条指令的意思是将一个寄存器中的数据移动到另外一个寄存器中, 当处理器执行到这条指令的时候, 便会按照指令的意思去实现相关的操作.

为了能够完成复杂的任务, 工程师们为 CPU 提供了一大堆指令, 来实现各种功能, 我们就把这一大堆指令称为**指令集(Instructions)**, 也就是**机器语言**. 二进制代码难以阅读和记忆, 于是我们又将二进制指令集转换为人类可以识别和记忆的符号, 这就是**汇编指令集**. 当然汇编语言仍然不能被 CPU 直接使用, 所以如果我们使用汇编编写了一段程序, 我们还需要一个汇编编译器, 来将汇编代码编程成机器代码.

```c
1000100111011000 // 机器指令
mov ax,bx        // 汇编指令
```

即便汇编语言对机器语言做了一层抽象, 仍然难以快速写出一段代码. 除了汇编语言仍然难以记忆, 还有如下两个原因:

- 不同的 CPU 有着不同的指令集, 市面上的 CPU 有 x86 架构的, arm 架构的等等, 如果要使用机器语言或者汇编语言来实现一个功能, 那么我们需要为每种架构的 CPU 编写特定的汇编代码.
- 在编写汇编代码时, 我们还需要了解和处理器架构相关的硬件知识, 比如寄存器, 内存, 操作 CPU 等等.

因此我们需要一种屏蔽了计算机架构细节的语言, 能适应多种不同 CPU 架构的语言, 能专心处理业务逻辑的语言, 诸如 C, C++, Java, C#, Python, JavaScript 等, 这些**高级语言**就应运而生了. 和汇编语言一样, 处理器也不能直接识别由高级语言所编写的代码, 通常会有两种方式来执行这些代码.

第一种是**解释执行**, 需要先将输入的源代码通过解析器编译成中间代码, 之后直接使用解释器解释执行中间代码, 然后直接输出结果.

![解释执行](https://edge.yancey.app/beg/gbs5kchb-1652032800141.webp)

第二种是**编译执行**. 采用这种方式时, 也需要先将源代码转换为中间代码, 然后我们的编译器再将中间代码编译成机器代码. 通常编译成的机器代码是以二进制文件形式存储的, 需要执行这段程序的时候直接执行二进制文件就可以了. 还可以使用虚拟机将编译后的机器代码保存在内存中, 然后直接执行内存中的二进制代码.

![编译执行](https://edge.yancey.app/beg/rql7jlta-1652032807344.webp)

## V8 工作原理概览

V8 其实是一个虚拟机, 虚拟机通过模拟实际计算机的各种功能来实现代码的执行, 如模拟实际计算机的 CPU, 堆栈, 寄存器等, 虚拟机还具有它自己的一套指令系统. 对于 JavaScript 代码来说, V8 就是它的整个世界, 当 V8 执行 JavaScript 代码时, 我们并不需要担心现实中不同操作系统的差异, 也不需要担心不同体系结构计算机的差异, 我们只需要按照虚拟机的规范写好代码就可以了.

V8 并没有采用某种单一的编译技术, 而是混合编译执行和解释执行这两种手段, 我们把这种混合使用编译器和解释器的技术称为 **JIT(Just In Time)**. 这是一种权衡策略, 因为这两种方法都各自有各自的优缺点, 解释执行的启动速度快, 但是执行时的速度慢, 而编译执行的启动速度慢, 但是执行时的速度快.

![V8 编译流水线](https://edge.yancey.app/beg/19m6ctx7-1652029505251.webp)

首先看上图左边部分, V8 启动执行 JavaScript 之前, 它还需要准备执行 JavaScript 时所需要的一些基础环境, 这些基础环境包括了**堆空间**, **栈空间**, **全局执行上下文**, **全局作用域**, **消息循环系统**, **内置函数**等, 这些内容都是在执行 JavaScript 过程中需要使用到的.

- JavaScript 全局执行上下文就包含了执行过程中的全局信息, 比如一些内置函数, 全局变量等信息;
- 全局作用域包含了一些全局变量, 在执行过程中的数据都需要存放在内存中;
- 而 V8 是采用了经典的堆和栈的内存管理模式, 所以 V8 还需要初始化内存中的堆和栈结构;
- 另外, 想要我们的 V8 系统活起来, 还需要初始化消息循环系统, 消息循环系统包含了消息驱动器和消息队列, 它如同 V8 的心脏, 不断接受消息并决策如何处理消息.

基础环境准备好之后, 接下来就可以向 V8 提交要执行的 JavaScript 代码了. V8 会进行一系列的**结构化**操作, 即词法分析, 语法分析等等, 此时就生成了 AST 和作用域.

有了 AST 和作用域, 接下来就可以生成字节码了, 字节码是介于 AST 和机器代码的中间代码. 但是与特定类型的机器代码无关, 解释器可以直接解释执行字节码, 或者通过编译器将其编译为二进制的机器代码再执行.

生成了字节码之后, 解释器就会按照顺序解释执行字节码, 并输出执行结果.

我们在解释器附近画了个监控机器人, 这是一个监控解释器执行状态的模块, 在解释执行字节码的过程中, 如果发现了某一段代码会被重复多次执行, 那么监控机器人就会将这段代码标记为**热点代码**. 当某段代码被标记为热点代码后, V8 就会将这段字节码丢给优化编译器, 优化编译器会在后台将字节码编译为二进制代码, 然后再对编译后的二进制代码执行优化操作, 优化后的二进制机器代码的执行效率会得到大幅提升. 如果下面再执行到这段代码时, 那么 V8 会优先选择优化之后的二进制代码, 这样代码的执行速度就会大幅提升.

不过由于 JavaScript 是一门动态语言, 对象的结构和属性是可以在运行时任意修改的, 而经过优化编译器优化过的代码只能针对某种固定的结构, 一旦在执行过程中, 对象的结构被动态修改了, 那么优化之后的代码势必会变成无效的代码, 这时候优化编译器就需要执行**反优化**操作, 经过反优化的代码, 下次执行时就会回退到解释器解释执行.

## JavaScript 的设计思想

我们知道 V8 的主要职责是用来执行 JavaScript 代码的, 在深入 V8 之前, 我们首先需要了解 JavaScript 这门语言的基本特性和设计思想.

JavaScript 借鉴了很多语言的特性, 比如 C 语言的基本语法, Java 的类型系统和内存管理, Scheme 的函数作为一等公民, 还有 Self 基于原型(prototype)的继承机制. 毫无疑问, JavaScript 是一门非常优秀的语言, 特别是**原型继承机制**和**函数是一等公民**这两个设计.

但操蛋的是, 由于历史原因, 很多错误的或者不合理的设计都被延续至今, 比如使用 new 加构造函数来创建对象, 这种方式的背后隐藏了太多的细节, 非常容易增加代码出错概率, 而且也大大增加了新手的学习成本;再比如初期的 JavaScript 没有块级作用域机制, 使得 JavaScript 需要采取变量提升的策略, 而变量提升又是非常反人性的设计.

因此在学习 V8 工作原理时, 我们就要格外关注 JavaScript 这些独特的设计思想和特性背后的实现. 比如, 为了实现函数是一等公民的特性, JavaScript 采取了基于对象的策略;再比如为了实现原型继承, V8 为每个对象引入了 `__proto__` 属性等等.

![JavaScript 的设计思想](https://edge.yancey.app/beg/ppo5m3ha-1652029158898.webp)

### 函数即对象

在 JavaScript 中, 函数是一种特殊的对象, 它和对象一样可以拥有属性和值, 但是函数和普通对象不同的是, 函数可以被调用, 所以一个函数被调用时, 它还需要关联相关的执行上下文. 并且除了使用函数名称来实现函数的调用, 还可以直接调用一个匿名函数. 在 V8 中, 会为函数对象添加了两个隐藏属性, 分别是 name 属性和 code 属性.

![函数对象具有隐藏属性](https://edge.yancey.app/beg/o859pe21-1652188558081.webp)

函数对象的默认的 name 属性值就是 anonymous, 表示该函数对象没有被设置名称, 比如立即执行函数. 其他情况我们可以通过 name 属性来获取函数的名称. 另外一个隐藏属性是 code 属性, 其值表示函数代码, 以字符串的形式存储在内存中. 当执行到一个函数调用语句时, V8 便会从函数对象中取出 code 属性值, 也就是函数代码, 然后再解释执行这段函数代码.

```ts
function foo() {
  console.log("Hello, world!");
}

foo.name; // 'foo'
```

### 谈一谈对象存储策略

我们知道对象是由一组组属性和值的集合, 因此内部使用字典存储是再好不过的了. 不过在 V8 实现对象存储时, 并没有完全采用字典的存储方式, 这主要是出于性能的考量. 因为字典是非线性的数据结构, 查询效率会低于线性的数据结构, V8 为了提升存储和查找效率, 采用了一套复杂的存储策略.

#### 常规属性(properties)和排序属性(element)

```ts
function Foo() {
  this[100] = "test-100";
  this[1] = "test-1";
  this["B"] = "bar-B";
  this[50] = "test-50";
  this[9] = "test-9";
  this[8] = "test-8";
  this[3] = "test-3";
  this[5] = "test-5";
  this["A"] = "bar-A";
  this["C"] = "bar-C";
}
const bar = new Foo();

for (const key in bar) {
  console.log(`index:${key}  value:${bar[key]}`);
}
```

![打印顺序](https://edge.yancey.app/beg/ztq1tyg2-1652197279731.jpg)

在上面这段代码中, 我们利用构造函数 Foo 创建了一个 bar 对象, 在构造函数中, 我们给 bar 对象设置了很多属性, 包括了数字属性和字符串属性, 然后我们枚举出来了 bar 对象中所有的属性, 并将其一一打印. 我们看到打印的顺序并没有按照我们定义的顺序, 规律大致如下:

- 设置的数字属性被最先打印出来了, 并且是按照数字大小的顺序打印的;
- 设置的字符串属性依然是按照之前的设置顺序打印的, 比如我们是按照 B, A, C 的顺序设置的, 打印出来依然是这个顺序.

之所以出现这样的结果, 是因为在 ECMAScript 规范中定义了**数字属性应该按照索引值大小升序排列, 字符串属性根据创建时的顺序升序排列**. 在这里我们把对象中的数字属性称为**排序属性**, 在 V8 中被称为 **elements**, 字符串属性就被称为**常规属性**, 在 V8 中被称为 **properties**.

在 V8 内部, 为了有效地提升存储和访问这两种属性的性能, 分别使用了两个线性数据结构来分别保存排序属性和常规属性, 具体结构如下图所示:

![V8 内部的对象构造](https://edge.yancey.app/beg/cf3fa67s-1652197503434.webp)

通过上图我们可以发现, bar 对象包含了两个隐藏属性: elements 属性和 properties 属性, elements 属性指向了 elements 对象, 在 elements 对象中, 会按照顺序存放排序属性, properties 属性则指向了 properties 对象, 在 properties 对象中, 会按照创建时的顺序保存了常规属性.

分解成这两种线性数据结构之后, 如果执行索引操作, 那么 V8 会先从 elements 属性中按照顺序读取所有的元素, 然后再在 properties 属性中读取所有的元素, 这样就完成一次索引操作. 这也就说为什么在遍历的过程中, 会先遍历排序属性, 然后再遍历常规属性.

#### 快属性和慢属性

将不同的属性分别保存到 elements 属性和 properties 属性中, 无疑简化了程序的复杂度, 但是在查找元素时, 却多了一步操作, 比如执行 `bar.B` 这个语句来查找 B 的属性值, 那么在 V8 会先查找出 properties 属性所指向的对象 properties, 然后再在 properties 对象中查找 B 属性, 这种方式在查找过程中增加了一步操作, 因此会影响到元素的查找效率.

基于这个原因, V8 采取了一个权衡的策略以加快查找属性的效率, 这个策略是将部分常规属性直接存储到对象本身, 我们把这称为**对象内属性(in-object properties)**. 对象在内存中的展现形式我们可以参看下图. 采用对象内属性之后, 常规属性就被保存到 bar 对象本身了, 这样当再次使用 `bar.B` 来查找 B 的属性值时, V8 就可以直接从 bar 对象本身去获取该值就可以了, 这种方式减少查找属性值的步骤, 增加了查找效率. 不过对象内属性的数量是固定的, 默认是 10 个, 如果添加的属性超出了对象分配的空间, 则它们将被保存在常规属性存储中.

![对象内属性](https://edge.yancey.app/beg/nyzhh27b-1652197794634.webp)

通常, 我们将保存在线性数据结构中的属性称之为**快属性**, 因为线性数据结构中只需要通过索引即可以访问到属性, 虽然访问线性结构的速度快, 但是如果从线性结构中添加或者删除大量的属性时, 则执行效率会非常低, 这会产生大量时间和内存开销.

因此, 如果一个对象的属性过多时, V8 就会采取另外一种存储策略, 那就是**慢属性**策略, 但慢属性的对象内部会有独立的非线性数据结构(词典) 作为属性存储容器. 所有的属性元信息不再是线性存储的, 而是直接保存在属性字典中.

![慢属性保存在字典中](https://edge.yancey.app/beg/m564o9ou-1652198315857.webp)

#### 实践: 在 Chrome 中查看对象布局

```ts
function Foo(property_num, element_num) {
  //添加可索引属性
  for (let i = 0; i < element_num; i++) {
    this[i] = `element-${i}`;
  }
  //添加常规属性
  for (let i = 0; i < property_num; i++) {
    const str = `property-${i}`;
    this[str] = str;
  }
}

const bar = new Foo(10, 10);
```

我们首先创建 10 个常规属性和 10 个 element, 在控制台先执行一下, 然后打开 Memory tab, 录制一下, 就得到了数据内存布局. 通过下图, 我们发现:

- 10 个常规属性作为对象内属性, 存放在 bar 函数内部;
- 10 个排序属性存放在 elements 中.

![new Foo(10, 10)](https://edge.yancey.app/beg/dvs3szq6-1652199279084.jpg)

接下来我们调整一下参数, `const bar2 = new Foo(20, 10)`, 使得常规属性变成 20 个. 由于创建的常用属性超过了 10 个, 所以另外 10 个常用属性就被保存到 properties 中了, 但因为 properties 中只有 10 个属性, 所以依然是线性的数据结构, 我们可以看其都是按照创建时的顺序来排列的. 因此:

- 10 个常规属性直接存放在 bar2 的对象内;
- 10 个常规属性以线性数据结构的方式存放在 properties 属性里面;
- 10 个数字属性存放在 elements 属性里面.

![new Foo(20, 10)](https://edge.yancey.app/beg/s19hzjb8-1652199703556.jpg)

接下来我们调整一下参数, `const bar3 = new Foo(100, 10)`, 使得常规属性变成 100 个. 由于创建的常用属性超过了 10 个, 所以另外 90 个常用属性就被保存到 properties 中了, 但因为 properties 中超过了 10 个属性, 所以就不是线性的数据结构了, 因此:

- 10 个常规属性直接存放在 bar2 的对象内;
- 90 个常规属性以非线性数据结构的方式存放在 properties 属性里面;
- 10 个数字属性存放在 elements 属性里面.

![new Foo(100, 10)](https://edge.yancey.app/beg/oqyv07ku-1652200735684.jpg)

观察上面的三张图片, 除了 elements 和 properties 属性, V8 还为每个对象实现了 map 属性和 `__proto__` 属性. `__proto__` 属性就是原型, 用来实现 JavaScript 继承的; 而 map 则是隐藏类, 用于在内存中快速查找对象属性, 我们后面都会介绍到.

### 函数声明和函数表达式

我们知道函数有**函数声明**和**函数表达式**两种形式. 如下 foo 为函数声明, bar 为函数表达式.

```ts
function foo() {}

const bar = function () {};
```

首先我们谈一谈表达式和语句的区别. 简单来说, 语句是为了进行某种操作, 一般情况下不需要返回值, 而表达式都是为了得到返回值, 一定会返回一个值. 举个例子, `if (a === 1) {}`, 这个 if 声明的就是一条语句, 而里面的 `a === 1` 就是一条表达式. 因为 `a === 1` 一定返回一个 boolean 类型.

#### 函数声明

我们先看看 V8 是怎么处理函数声明的. 以下面的代码为例:

```ts
var x = 5;
function foo() {
  console.log("Foo");
}
```

![上面这段代码的作用域](https://edge.yancey.app/beg/1shqp0m0-1652278774490.webp)

函数声明和变量声明类似, V8 在编译阶段, 都会对其执行变量提升的操作, 将它们提升到作用域中, 在执行阶段, 如果使用了某个变量, 就可以直接去作用域中去查找. 不过 V8 对于提升函数和提升变量的策略是不同的, 如果提升了一个变量, 那么 V8 在将变量提升到作用域中时, 还会为其设置默认值 undefined, 如果是函数声明, 那么 V8 会在内存中创建该函数对象, 并提升整个函数对象.

因此对于 `var x = 5;`, 在 V8 执行 var x = 5 这段代码时, 会认为它是两段代码, 一段是定义变量的语句, 一段是赋值的表达式, 如下所示:

```ts
var x = undefined;
x = 5;
```

首先, 在变量提升阶段, V8 并不会执行赋值的表达式, 该阶段只会分析基础的语句, 比如变量的定义, 函数的声明. 而这两行代码是在不同的阶段完成的, `var x` 是在编译阶段完成的, 也可以说是在变量提升阶段完成的, 而 `x = 5` 是表达式, 所有的表达式都是在执行阶段完成的. 在变量提升阶段, V8 将这些变量存放在作用域时, 还会给它们赋一个默认的 undefined 值, 所以在定义一个普通的变量之前, 使用该变量, 那么该变量的值就是 undefined.

对于一个普通的函数声明, 执行它并没有输出任何内容, 所以可以肯定, 函数声明并不是一个表达式, 而是一个语句. V8 在变量提升阶段, 如果遇到函数声明, 那么 V8 同样会对该函数声明执行变量提升操作. 函数也是一个对象, 所以在编译阶段, V8 就会将整个函数对象提升到作用域中, 但不是给该函数名称赋一个 undefined, 而是 V8 会在内存中为声明生成函数对象, 并将该对象提升到作用域中.

#### 函数表达式

我们在一个表达式中使用 function 来定义一个函数, 那么就把该函数称为函数表达式. 它与函数声明有三个区别:

- 函数表达式是在表达式语句中使用 function 的, 最典型的表达式是 **a = b** 这种形式, 因为函数也是一个对象, 我们把 **a = function () {}** 这种方式称为函数表达式;
- 在函数表达式中, 可以省略函数名称, 从而创建匿名函数(anonymous functions);
- 一个函数表达式可以被用作一个即时调用的函数表达式, IIFE(Immediately Invoked Function Expression).

以下面这段代码为例:

```ts
foo();

var foo = function () {
  console.log("foo");
};
```

不用多数, 我们知道它肯定报错, 因为变量提升, 可以拆分成如下的形式:

```ts
var foo = undefined;
foo = function () {
  console.log("foo");
};
```

上面的代码中, 第一行是声明语句, 所以 V8 在解析阶段, 就会在作用域中创建该对象, 并将该对象设置为 undefined, 第二行是函数表达式, 在编译阶段, V8 并不会处理函数表达式, 所以也就不会将该函数表达式提升到作用域中了. 那么在函数表达式之前调用该函数 foo, 此时的 foo 只是指向了 undefined, 所以就相当于调用一个 undefined, 而 undefined 只是一个原生对象, 并不是函数, 所以当然会报错了.

#### IIFE

现在我们知道了, 在编译阶段, V8 并不会处理函数表达式, 而 JavaScript 中的立即函数调用表达式正是使用了这个特性来实现了非常广泛的应用. 看 `(a = 3)` 这个代码, JavaScript 中有一个圆括号运算符, 圆括号里面可以放一个表达式, 整个语句也是一个表达式, 最终输出 3.

同理, 如果在小括号里面放上一段函数的定义, 因为小括号之间存放的必须是表达式, 所以如果在小括号里面定义一个函数, 那么 V8 就会把这个函数看成是函数表达式, 执行时它会返回一个函数对象. 如果我直接在表达式后面加上调用的括号, 这就称为立即调用函数表达式(IIFE)

```ts
(function () {
  //statements
})();
```

因为函数立即表达式也是一个表达式, 所以 V8 在编译阶段, 并不会为该表达式创建函数对象. **这样的一个好处就是不会污染环境, 函数和函数内部的变量都不会被其他部分的代码访问到**. 在 ES6 之前, JavaScript 中没有私有作用域的概念, 如果在多人开发的项目中, 你模块中的变量可能覆盖掉别人的变量, 所以使用函数立即表达式就可以将我们内部变量封装起来, 避免了相互之间的变量污染.

另外, 因为函数立即表达式是立即执行的, 所以将一个函数立即表达式赋给一个变量时, 不是存储 IIFE 本身, 而是存储 IIFE 执行后返回的结果. 如下所示:

```ts
var a = (function () {
  return 1;
})();

console.log(a); // 1
```

### 闭包

因为函数是一种特殊的对象, 所以在 JavaScript 中, 函数可以赋值给一个变量, 也可以作为函数的参数, 还可以作为函数的返回值. **如果某个编程语言的函数, 可以和这个语言的数据类型做一样的事情, 我们就把这个语言中的函数称为一等公民**. 但是由于函数的**可被调用**的特性, 使得实现函数的可赋值, 可传参和可作为返回值等特性变得有一点麻烦.

我们知道, 在执行 JavaScript 函数的过程中, 为了实现变量的查找, V8 会为其维护一个作用域链, 如果函数中使用了某个变量, 但是在函数内部又没有定义该变量, 那么函数就会沿着作用域链去外部的作用域中查找该变量, 具体流程如下图所示:

![函数作用域链](https://edge.yancey.app/beg/yteojceh-1652189472973.webp)

从图中可以看出, 当函数内部引用了外部的变量时, 使用这个函数进行赋值, 传参或作为返回值, 我们还需要保证这些被引用的外部变量是确定存在的, 这就是让函数作为一等公民麻烦的地方, 因为虚拟机还需要处理函数引用的外部变量. 我们来看一段简单的代码:

```ts
function foo() {
  var number = 1;
  function bar() {
    number++;
    console.log(number);
  }
  return bar;
}
var mybar = foo();
mybar();
```

我们在 foo 函数中定义了一个新的 bar 函数, 并且 bar 函数引用了 foo 函数中的变量 number, 当调用 foo 函数的时候, 它会返回 bar 函数. 那么所谓的**函数是一等公民**就体现在, 如果要返回函数 bar 给外部, 那么即便 foo 函数执行结束了, 其内部定义的 number 变量也不能被销毁, 因为 bar 函数依然引用了该变量. 我们也把这种将外部变量和和函数绑定起来的技术称为闭包.

## V8 编译流水线

我们把 V8 执行 JavaScript 代码的这套流程称之为 V8 的编译流水线. 它涉及 JIT, 延迟解析, 隐藏类, 内联缓存等等. 这些技术决定着一段 JavaScript 代码能否正常执行, 以及代码的执行效率.

比如 V8 中使用的隐藏类(Hide Class), 这是将 JavaScript 中动态类型转换为静态类型的一种技术, 可以消除动态类型的语言执行速度过慢的问题, 那么我们在编写 JavaScript 时, 就可以充分利用好隐藏类这种强大的优化特性, 写出更加高效的代码. 再比如, V8 实现了 JavaScript 代码的惰性解析, 目的是为了加速代码的启动速度, 通过对惰性解析机制的学习, 我们可以优化代码来更加适应这个机制, 从而提高程序性能.

我们会从运行时环境, 闭包, 字节码, 惰性类等方面阐述 V8 编译流水线.

## 运行时环境

在执行 JavaScript 代码之前, V8 就已经准备好了代码的运行时环境, 这个环境包括了堆空间和栈空间, 全局执行上下文, 全局作用域, 内置的内建函数, 宿主环境提供的扩展函数和对象, 还有消息循环系统. 准备好运行时环境之后, V8 才可以执行 JavaScript 代码, 这包括解析源码, 生成字节码, 解释执行或者编译执行这一系列操作.

在聊运行 V8 的运行时环境, 我们先聊 V8 的宿主环境. 在浏览器环境, 浏览器为 V8 提供基础的消息循环系统, 全局变量, Web API, 而 V8 的核心是实现了 ECMAScript 标准, 这相当于病毒自己的 DNA 或者 RNA, V8 只提供了 ECMAScript 定义的一些对象和一些核心的函数, 这包括了 Object, Function, String. 除此之外, V8 还提供了垃圾回收器, 协程等基础内容, 不过这些功能依然需要宿主环境的配合才能完整执行. 此外, Node.js 也是 V8 的另外一种宿主环境, 它提供了不同的宿主对象和宿主的 API, 但是整个流程依然是相同的, 比如 Node.js 也会提供一套消息循环系统, 也会提供一个运行时的主线程.

如果 V8 使用不当, 比如不规范的代码触发了频繁的垃圾回收, 或者某个函数执行时间过久, 这些都会占用宿主环境的主线程, 从而影响到程序的执行效率, 甚至导致宿主环境的卡死.

![V8 和宿主环境](https://edge.yancey.app/beg/nf369msu-1652718837225.webp)

### 构造数据存储空间: 堆空间和栈空间

由于 V8 是寄生在浏览器或者 Node.js 这些宿主中的, 因此, V8 也是被这些宿主启动的. 比如, 在 Chrome 中, 只要打开一个渲染进程, 渲染进程便会初始化 V8, 同时初始化堆空间和栈空间.

栈空间主要是用来管理 JavaScript 函数调用的, 栈是内存中连续的一块空间, 同时栈结构是**先进后出**的策略. 在函数调用过程中, 涉及到上下文相关的内容都会存放在栈上, 比如原生类型, 引用到的对象的地址, 函数的执行状态, this 值等都会存在在栈上. 当一个函数执行结束, 那么该函数的执行上下文便会被销毁掉.

栈空间的最大的特点是空间连续, 所以在栈中每个元素的地址都是固定的, 因此栈空间的查找效率非常高, 但是通常在内存中, 很难分配到一块很大的连续空间, 因此, V8 对栈空间的大小做了限制, 如果函数调用层过深, 那么 V8 就有可能抛出栈溢出的错误.

如果有一些占用内存比较大的数据, 或者不需要存储在连续空间中的数据, 使用栈空间就显得不是太合适了, 所以 V8 又使用了堆空间. 堆空间是一种树形的存储结构, 用来存储对象类型的离散的数据, 由于堆空间中的数据不是线性存储的, 所以堆空间可以存放很多数据, 但是读取的速度会比较慢. JavaScript 中除了原生类型的数据, 其他的都是对象类型, 诸如函数, 数组, 在浏览器中还有 window 对象, document 对象等, 这些都是存在堆空间的.

下面我们从函数调用角度来分析堆和栈, 以及函数调用是如何影响到内存布局的.

```ts
function foo() {
  foo();
}

function foo() {
  setTimeout(foo, 0);
}

function foo() {
  return Promise.resolve().then(foo);
}
```

上面的三段代码, 如果执行 foo 函数, 会有三种不同的结局:

1. 第一段代码是在同一个任务中重复调用嵌套的 foo 函数, V8 就会报告栈溢出的错误.
2. 第二段代码是使用 setTimeout 让 foo 函数在不同的任务中执行, 不会栈溢出, 也不会卡死. 这段代码之所以不会导致栈溢出, 是因为 setTimeout 会使得 foo 函数在消息队列后面的任务中执行, 所以不会影响到当前的栈结构
3. 第三段代码是在同一个任务中执行 foo 函数, 但是却不是嵌套执行, 不会栈溢出, 但页面会卡死. 这是因为在这一轮任务里不停地创建微任务, 执行, 创建, 执行, 创建... 虽然不会爆栈, 但也无法去执行下一个任务, 主线程被卡在这里了, 所以页面会卡死

这是因为, V8 执行这三种不同代码时, 它们的内存布局是不同的, 而不同的内存布局又会影响到代码的执行逻辑, 因此我们需要了解 JavaScript 执行时的内存布局.

在讲内存布局之前, 我们先说下大部分高级语言为什么采用栈这种结构来管理函数调用. 这与函数的特性有关:

1. 第一个特点是函数可以被调用, 你可以在一个函数中调用另外一个函数, 当函数调用发生时, 执行代码的控制权将从父函数转移到子函数, 子函数执行结束之后, 又会将代码执行控制权返还给父函数;
2. 第二个特点是函数具有作用域机制, 所谓作用域机制, 是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离, 在函数内部定义的变量我们也称为临时变量, 临时变量只能在该函数中被访问, 外部函数通常无权访问, 当函数执行结束之后, 存放在内存中的临时变量也随之被销毁.

比如下面这段 C 代码:

```cpp
int getZ()
{
    return 4;
}
int add(int x, int y)
{
    int z = getZ();
    return x + y + z;
}
int main()
{
    int x = 5;
    int y = 6;
    int ret = add(x, y);
}
```

1. 当 main 函数调用 add 函数时, 需要将代码执行控制权交给 add 函数;
2. 然后 add 函数又调用了 getZ 函数, 于是又将代码控制权转交给 getZ 函数;
3. 接下来 getZ 函数执行完成, 需要将控制权返回给 add 函数;
4. 同样当 add 函数执行结束之后, 需要将控制权返还给 main 函数;
5. 然后 main 函数继续向下执行.

通过上述分析, 我们可以得出, **函数调用者的生命周期总是长于被调用者(后进), 并且被调用者的生命周期总是先于调用者的生命周期结束(先出)**.

![嵌套调用时函数的生命周期](https://edge.yancey.app/beg/y154oy5t-1652971591868.webp)

再谈一谈作用域, 作用域机制通常表现在函数执行时, 会在内存中分配函数内部的变量, 上下文等数据, 在函数执行完成之后, 这些内部数据会被销毁掉. **所以站在函数资源分配和回收角度来看, 被调用函数的资源分配总是晚于调用函数(后进), 而函数资源的释放则总是先于调用函数(先出)**.

![函数资源分配流程](https://edge.yancey.app/beg/xlh7ysp4-1652971666001.webp)

所以既然都是后进先出的结构, 那么使用栈是再合适不过的了, 因此我们会使用栈这种数据结构来管理函数的调用过程, 我们也把管理函数调用过程的栈结构称之为**调用栈**. 我们来用栈的思想分析下面一个例子:

```cpp
int add(num1,num2){
    int x = num1;
    int y = num2;
    int ret = x + y;
    return ret;
}


int main()
{
    int x = 5;
    int y = 6;
    x = 100;
    int z = add(x,y);
    return z;
}
```

首先执行 main, 会把 x, y 压入栈中, 当执行到 `int z = add(x, y)` 时, 会把形参 num1, num2, 再把变量 x, y, ret 的值依次压栈中. 当 add 函数执行完成之后, 需要将执行代码的控制权转交给 main 函数, 这意味着需要将栈的状态恢复到 main 函数上次执行时的状态, 我们把这个过程叫**恢复现场**.

恢复现场的方法很简单, 就是在寄存器中保存一个永远指向当前栈顶的指针, 栈顶指针的作用就是告诉你应该往哪个位置添加新元素, 这个指针通常存放在 esp 寄存器中. 如果你想往栈中添加一个元素, 那么你需要先根据 esp 寄存器找到当前栈顶的位置, 然后在栈顶上方添加新元素, 新元素添加之后, 还需要将新元素的地址更新到 esp 寄存器中. 下面这个图, 在 add 函数 return ret 的时候, ret 被压入栈中, 同时 esp 寄存器也指向 ret.

![add 函数即将执行结束的状态](https://edge.yancey.app/beg/3b9f4xo5-1652972294496.webp)

因此在 add 函数执行完毕后, 将 esp 的指针向下移动到之前 main 函数执行时的地方就可以. 当然 CPU 是怎么知道要移动到这个地址呢? CPU 的解决方法是增加了另外一个 ebp 寄存器, 用来保存当前函数的起始位置, 我们把一个函数的起始位置也称为栈帧指针(每个栈帧对应着一个未运行完的函数, 栈帧中保存了该函数的返回地址和局部变量), ebp 寄存器中保存的就是当前函数的栈帧指针. 在 main 函数调用 add 函数的时候, main 函数的栈顶指针就变成了 add 函数的栈帧指针, 所以需要将 main 函数的栈顶指针保存到 ebp 中, 当 add 函数执行结束之后, 我需要销毁 add 函数的栈帧, 并恢复 main 函数的栈帧, 那么只需要取出 main 函数的栈顶指针写到 esp 中即可, 这就相当于将栈顶指针移动到 main 函数的区域.

![恢复 main 函数执行现场](https://edge.yancey.app/beg/egf81hy8-1652972303266.webp)

不过现在仍然不能执行 main 函数. 因为 main 函数也有它自己的栈帧指针, 在执行 main 函数之前, 我们还需恢复它的栈帧指针. 通常的方法是在 main 函数中调用 add 函数时, CPU 会将当前 main 函数的栈帧指针保存在栈中. 当函数调用结束之后, 就需要恢复 main 函数的执行现场了, 首先取出 ebp 中的指针, 写入 esp 中, 然后从栈中取出之前保留的 main 的栈帧地址, 将其写入 ebp 中, 到了这里 ebp 和 esp 就都恢复了, 可以继续执行 main 函数了.

![当前 main 函数的栈帧指针保存在栈](https://edge.yancey.app/beg/8xz8i998-1652972667151.webp)

> 关于 CPU, 寄存器, 内存等知识可以看[浅析 CPU 是如何执行二进制机器码的](https://www.yanceyleo.com/post/950d248c-3127-4fc9-8dfc-f460c439a38d)这篇文章.

回到上面的 JavaScript 代码, 在 JavaScript 中, 函数的执行过程也是类似的, 如果调用一个新函数, 那么 V8 会为该函数创建栈帧, 等函数执行结束之后, 销毁该栈帧, 而栈结构的容量是固定的, 所有如果重复嵌套执行一个函数, 那么就会导致栈会栈溢出.

因此, 栈有以下两个优势:

- 栈的结构和非常适合函数调用过程.
- 在栈上分配资源和销毁资源的速度非常快, 这主要归结于栈空间是连续的, 分配空间和销毁空间只需要移动下指针就可以了.

不过正是因为栈是连续的, 所以要想在内存中分配一块连续的大空间是非常难的, 因此栈空间是有限的. 因为栈空间是有限的, 这就导致我们在编写程序的时候, 经常一不小心就会导致栈溢出, 比如函数循环嵌套层次太多, 或者在栈上分配的数据过大, 都会导致栈溢出, 基于栈不方便存放大的数据, 因此我们使用了另外一种数据结构用来保存一些大数据, 这就是**堆**. 和栈空间不同, 存放在堆空间中的数据是不要求连续存放的, 从堆上分配内存块没有固定模式的, 你可以在任何时候分配和释放它.

### 全局执行上下文和全局作用域

V8 初始化了基础的存储空间之后, 接下来就需要初始化全局执行上下文和全局作用域了, 当 V8 开始执行一段可执行代码时, 会生成一个执行上下文. V8 用执行上下文来维护执行当前代码所需要的变量声明, this 指向等.

执行上下文中主要包含三部分, 变量环境, 词法环境和 this 关键字. 比如在浏览器的环境中, 全局执行上下文中就包括了 window 对象, 还有默认指向 window 的 this 关键字, 另外还有一些 Web API 函数, 诸如 setTimeout, XMLHttpRequest 等内容.

而词法环境中, 则包含了使用 let, const 等变量的内容.

全局执行上下文在 V8 的生存周期内是不会被销毁的, 它会一直保存在堆中, 这样当下次在需要使用函数或者全局变量时, 就不需要重新创建了. 另外, 当你执行了一段全局代码时, 如果全局代码中有声明的函数或者定义的变量, 那么函数对象和声明的变量都会被添加到全局执行上下文中. 比如下面这段代码, V8 在执行这段代码的过程中, 会在全局执行上下文中添加变量 x 和函数 show_x.

```ts
var x = 1;
function show_x() {
  console.log(x);
}
```

我们需要注意全局作用域和全局执行上下文的关系, 在 ES6 中, 同一个全局执行上下文中, 都能存在多个作用域. 比如下面这段代码在执行时, 就会有两个对应的作用域, 一个是全局作用域, 另外一个是括号内部的作用域, 但是这些内容都会保存到全局执行上下文中.

```ts
var x = 5;
{
  let y = 2;
  const z = 3;
}
```

当 V8 调用了一个函数时, 就会进入函数的执行上下文, 这时候全局执行上下文和当前的函数执行上下文就形成了一个栈结构. 比如执行下面这段代码:

```ts
var x = 1;
function show_x() {
  console.log(x);
}
function bar() {
  show_x();
}
bar();
```

当执行到 show_x 的时候, 其栈状态如下图所示:

![函数调用栈](https://edge.yancey.app/beg/pg7kib8z-1652719750511.webp)

### 构造事件循环系统

有了堆空间和栈空间, 生成了全局执行上下文和全局作用域, JavaScript 代码仍然是不可以被执行的, 这是因为 V8 还需要有一个主线程, 用来执行 JavaScript 和执行垃圾回收等工作. V8 是寄生在宿主环境中的, 它并没有自己的主线程, 而是使用宿主所提供的主线程, V8 所执行的代码都是在宿主的主线程上执行的.

只有一个主线程依然不行, 因为如果你开启一个线程, 在该线程执行一段代码, 那么当该线程执行完这段代码之后, 就会自动退出了, 执行过程中的一些栈上的数据也随之被销毁, 下次再执行另外一个段代码时, 你还需要重新启动一个线程, 重新初始化栈数据, 这会严重影响到程序执行时的性能.

为了在执行完代码之后, 让线程继续运行, 通常的做法是在代码中添加一个循环语句, 在循环语句中监听下个事件, 比如你要执行另外一个语句, 那么激活该循环就可以执行了. 比如下面的模拟代码, 使用了一个循环, 不同地获取新的任务, 一旦有新的任务, 便立即执行该任务.

```c++

while(1){
  Task task = GetNewTask();
  RunTask(task);
}
```

如果主线程正在执行一个任务, 这时候又来了一个新任务, 比如 V8 正在操作 DOM, 这时候浏览器的网络线程完成了一个页面下载的任务, 而且 V8 注册监听下载完成的事件, 那么这种情况下就需要引入一个消息队列, 让下载完成的事件暂存到消息队列中, 等当前的任务执行结束之后, 再从消息队列中取出正在排队的任务. 当执行完一个任务之后, 我们的事件循环系统会重复这个过程, 继续从消息队列中取出并执行下个任务. 这就是事件循环.

需要注意的是, 因为所有的任务都是运行在主线程的, 在浏览器的页面中, V8 会和页面共用主线程, 共用消息队列, 所以如果 V8 执行一个函数过久, 会影响到浏览器页面的交互性能.

## 谈一谈 V8 的惰性解析

在编译 JavaScript 代码的过程中, V8 并不会一次性将所有的 JavaScript 解析为中间代码, 这主要是基于以下两点:

- 首先, 如果一次解析和编译所有的 JavaScript 代码, 过多的代码会增加编译时间, 这会严重影响到首次执行 JavaScript 代码的速度, 让用户感觉到卡顿. 因为有时候一个页面的 JavaScript 代码都有 10 多兆, 如果要将所有的代码一次性解析编译完成, 那么会大大增加用户的等待时间;

- 其次, 解析完成的字节码和编译之后的机器代码都会存放在内存中, 如果一次性解析和编译所有 JavaScript 代码, 那么这些中间代码和机器代码将会一直占用内存, 特别是在手机普及的年代, 内存是非常宝贵的资源.

因此, V8 是实现了**惰性解析**. 所谓惰性解析是指解析器在解析的过程中, 如果遇到函数声明, 那么会跳过函数内部的代码, 并不会为其生成 AST 和字节码, 而仅仅生成顶层代码的 AST 和字节码.

```ts
function foo(a, b) {
  var d = 100;
  var f = 10;
  return d + f + a + b;
}
var a = 1;
var c = 4;
foo(1, 5);
```

当把这段代码交给 V8 处理时, V8 会至上而下解析这段代码, 在解析过程中首先会遇到 foo 函数, 由于这只是一个函数声明语句, V8 在这个阶段只需要将该函数转换为函数对象, 但是并没有解析和编译函数内部的代码, 所以也不会为 foo 函数的内部代码生成抽象语法树. 然后继续往下解析, 由于后续的代码都是顶层代码, 所以 V8 会为它们生成抽象语法树.

代码解析完成之后, V8 便会按照顺序自上而下执行代码, 首先会先执行 `a = 1` 和 `c = 4` 这两个赋值表达式, 接下来执行 foo 函数的调用, 过程是从 foo 函数对象中取出函数代码, 然后和编译顶层代码一样, V8 会先编译 foo 函数的代码, 编译时同样需要先将其编译为抽象语法树和字节码, 然后再解释执行.

对于普通函数, V8 确实是这么解析的, 但由于存在闭包, 一切都变得复杂起来了. 这是因为闭包有三大特性:

- 可以在 JavaScript 函数内部定义新的函数;
- 内部函数中访问父函数中定义的变量;
- 因为 JavaScript 中的函数是一等公民, 所以函数可以作为另外一个函数的返回值.

```ts
function foo() {
  var d = 20;
  return function inner(a, b) {
    const c = a + b + d;
    return c;
  };
}
const f = foo();
```

我们考察上面这段代码.

- 当调用 foo 函数时, foo 函数会将它的内部函数 inner 返回给全局变量 f;
- 然后 foo 函数执行结束, 执行上下文被 V8 销毁;
- 虽然 foo 函数的执行上下文被销毁了, 但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d.

按照通用的做法, d 已经被 v8 销毁了, 但是由于存活的函数 inner 依然引用了 foo 函数中的变量 d, 这样就会带来两个问题:

- 当 foo 执行结束时, 变量 d 该不该被销毁？如果不应该被销毁, 那么应该采用什么策略？
- 如果采用了惰性解析, 那么当执行到 foo 函数时, V8 只会解析 foo 函数, 而不会解析内部代码, 也就是并不会解析内部的 inner 函数, 那么这时候 V8 就不知道 inner 函数中是否引用了 foo 函数的变量 d.

我们佐以下面这张图执行堆栈图来分析一下:

![堆栈图](https://edge.yancey.app/beg/zv8jkgew-1653035189629.jpeg)

从上图可以看出来, 在执行全局代码时, V8 会将全局执行上下文压入到调用栈中, 然后进入执行 foo 函数的调用过程, 这时候 V8 会为 foo 函数创建执行上下文, 执行上下文中包括了变量 d, 然后将 foo 函数的执行上下文压入栈中, foo 函数执行结束之后, foo 函数执行上下文从栈中弹出, 这时候 foo 执行上下文中的变量 d 也随之被销毁.

但是这时候, 由于 inner 函数被保存到全局变量中了, 所以 inner 函数依然存在, 最关键的地方在于 inner 函数使用了 foo 函数中的变量 d, 所以正常的处理方式应该是 foo 函数的执行上下文虽然被销毁了, 但是 inner 函数引用的 foo 函数中的变量却不能被销毁, 那么 V8 就需要为这种情况做特殊处理, 需要保证即便 foo 函数执行结束, 但是 foo 函数中的 d 变量依然保持在内存中, 不能随着 foo 函数的执行上下文被销毁掉.

基于此, V8 在执行 foo 函数的阶段, 虽然采取了惰性解析, 不会解析和执行 foo 函数中的 inner 函数, 但是 V8 还是需要判断 inner 函数是否引用了 foo 函数中的变量, 负责处理这个任务的模块叫做**预解析器**.

V8 引入预解析器, 比如当解析顶层代码的时候, 遇到了一个函数, 那么预解析器并不会直接跳过该函数, 而是对该函数做一次快速的预解析. 第一, 是判断当前函数是不是存在一些语法上的错误; 第二, 除了检查语法错误之外, 预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量, 如果引用了外部的变量, 预解析器会将栈中的变量复制到堆中, 在下次执行到该函数的时候, 直接使用堆中的引用, 这样就解决了闭包所带来的问题.

## 谈一谈字节码

## 从 V8 看事件循环系统

事件循环系统和 JavaScript 中的难点, 异步编程特性紧密相关. 我们知道, JavaScript 是单线程的, JavaScript 代码都是在一个线程上执行, 如果同一时间发送了多个 JavaScript 执行的请求, 就需要排队, 也就是进行异步编程. V8 的事件循环系统会调度这些排队任务, 保证 JavaScript 代码被 V8 有序地执行. 因此也可以说, 事件循环系统就是 V8 的心脏, 它驱动了 V8 的持续工作.

## 从 V8 看垃圾回收

我们知道 JavaScript 是一种自动垃圾回收的语言, V8 在执行垃圾回收时, 会占用主线程的资源. 如果我们编写的程序频繁触发垃圾回收, 那么无疑会阻塞主线程, 这也是我们经常会遇到的一个问题. 因此我们需要知道 V8 是如何分配内存数据的, 以及这些数据是如何被回收的. 这样在遇到内存问题时, 就知道如何去排查了.

## 实践: 玩一玩 D8

要查看 V8 中间生成的一些结构, 可以使用 V8 提供的调试工具 D8 来查看. 注意不要使用 `brew install v8` 安装, 因为这个是生产环境的 V8, 而我们需要安装 debug 版本的 V8, 才可以进行一些调试. 我们可以使用 [jsvu](https://github.com/GoogleChromeLabs/jsvu), 它是一个 JavaScript 引擎版本更新器, 我们可以通过这个工具安装 debug 版本的 V8.

![V8 debug](https://edge.yancey.app/beg/sjzukz6d-1652107415952.jpg)

```ts
const name = "yancey";

function sayHi() {
  const params = {};
  return "Hi";
}
```

以上面这段代码为例, 我们执行 `d8 --print-ast index.js`, 就可以获取到抽象语法树的结构.

```ts
[generating bytecode for function: ]
--- AST ---
FUNC at 0
. KIND 0
. LITERAL ID 0
. SUSPEND COUNT 0
. NAME ""
. INFERRED NAME ""
. DECLS
. . VARIABLE (0x7fa8e701f250) (mode = CONST, assigned = false) "name"
. . FUNCTION "sayHi" = function sayHi
. BLOCK NOCOMPLETIONS at -1
. . EXPRESSION STATEMENT at 13
. . . INIT at 13
. . . . VAR PROXY context[2] (0x7fa8e701f250) (mode = CONST, assigned = false) "name"
. . . . LITERAL "yancey"
```

我们执行 `d8 --print-scopes test.js`, 就可以获取到作用域, 我们看到了 sayHi 和 name 都被加入到了全作用域, params 被加入到 sayHi 函数的内部作用域.

```ts
Inner function scope:
function sayHi () { // (0x7f832e00cee0) (38, 80)
  // NormalFunction
  // 2 heap slots
  // local vars:
  CONST params;  // (0x7f832e00fa48) never assigned
}
Global scope:
global { // (0x7f832e00cc30) (0, 80)
  // will be compiled
  // NormalFunction
  // 1 stack slots
  // 3 heap slots
  // temporary vars:
  TEMPORARY .result;  // (0x7f832e00d130) local[0]
  // local vars:
  CONST name;  // (0x7f832e00ce50) context[2], never assigned
  VAR sayHi;  // (0x7f832e00d0a0)

  function sayHi () { // (0x7f832e00cee0) (38, 80)
    // lazily parsed
    // NormalFunction
    // 2 heap slots
  }
}
```

我们可以通过 `d8 --print-bytecode index.js` 来获取字节码.

```ts
[generated bytecode for function:  (0x325400253915 <SharedFunctionInfo>)]
Bytecode length: 38
Parameter count 1
Register count 3
Frame size 24
Bytecode age: 0
         0x3254002539e2 @    0 : 13 00             LdaConstant [0]
         0x3254002539e4 @    2 : c3                Star1
         0x3254002539e5 @    3 : 19 fe f8          Mov <closure>, r2
         0x3254002539e8 @    6 : 65 58 01 f9 02    CallRuntime [DeclareGlobals], r1-r2
         0x3254002539ed @   11 : 13 01             LdaConstant [1]
         0x3254002539ef @   13 : 25 02             StaCurrentContextSlot [2]
         0x3254002539f1 @   15 : 21 02 00          LdaGlobal [2], [0]
         0x3254002539f4 @   18 : c3                Star1
         0x3254002539f5 @   19 : 61 f9 02          CallUndefinedReceiver0 r1, [2]
         0x3254002539f8 @   22 : 21 02 00          LdaGlobal [2], [0]
         0x3254002539fb @   25 : c3                Star1
         0x3254002539fc @   26 : 61 f9 04          CallUndefinedReceiver0 r1, [4]
         0x3254002539ff @   29 : 21 02 00          LdaGlobal [2], [0]
         0x325400253a02 @   32 : c3                Star1
         0x325400253a03 @   33 : 61 f9 06          CallUndefinedReceiver0 r1, [6]
         0x325400253a06 @   36 : c4                Star0
         0x325400253a07 @   37 : a9                Return
Constant pool (size = 3)
0x3254002539ad: [FixedArray] in OldSpace
 - map: 0x325400002239 <Map>
 - length: 3
           0: 0x325400253965 <FixedArray[2]>
           1: 0x3254002538c9 <String[6]: #yancey>
           2: 0x3254002538dd <String[5]: #sayHi>
Handler Table (size = 0)
Source Position Table (size = 0)
[generated bytecode for function: sayHi (0x325400253975 <SharedFunctionInfo sayHi>)]
Bytecode length: 5
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
         0x325400253b46 @    0 : 7d                CreateEmptyObjectLiteral
         0x325400253b47 @    1 : c4                Star0
         0x325400253b48 @    2 : 13 00             LdaConstant [0]
         0x325400253b4a @    4 : a9                Return
Constant pool (size = 1)
0x325400253b19: [FixedArray] in OldSpace
 - map: 0x325400002239 <Map>
 - length: 1
           0: 0x325400253ae1 <String[2]: #Hi>
Handler Table (size = 0)
Source Position Table (size = 0)
```

生成字节码之后, 解释器会解释执行这段字节码, 如果重复执行了某段代码, 监控器就会将其标记为热点代码, 并提交给编译器优化执行, 如果我们想要查看那些代码被优化了, 可以使用下面的命令. 当然我们的代码太简单了, 没有被标记成热点代码的情况.

```shell
d8 --trace-opt test.js
```

如果要查看那些代码被反优化了, 可以使用如下命令行来查看.

```shell
pt --trace-deopt test.js
```

## 结语

![总结](https://edge.yancey.app/beg/8fqa4v7z-1652030438219.jpeg)
